# モデル
図は`puml`を参照

## 方針
### 大筋
+ ドメイン層にロジックを書くって何？を試す
+ 登録処理をとにかくメモリで完結すると思って書く
  + 副作用を伴うds層で`void 登録する(名前)`ではなくて、ドメイン層で`登録済み 登録する(名前)`を徹底する
+ エラーは適切に返却する
  + バリデ
  + 不正登録
+ モデリングの段階で全てを脳内実装をする
+ パッケージも書く
+ モデリングの時点でScalaを想定したモデリングをする
+ Either前面推し
  + 振り切ってみたらどうなるかためす
  + Scalaで初モナド

### 副作用
+ ドメイン層には例外なく副作用を認めない
+ ドメイン層はモック化等が必要なく、xmlの記述も不要で、全てのOSやマシンで動き、現在日時に左右されてはならない

### 何でも保持するエンティティにしない
+ `AppliedUser`にはクレカがありユーザIDはない
  + IDはこれから払い出すので無くて当然
  + クレカは別でも良かったけど、まぁ「申込情報」という扱いでまとめた
    + そういうクラスにしても良かったけど、ちょっと疲れたので
+ 逆に例えばコース変更時はまた別の`User`を作る
  + こちらはクレカは関係ないので保持しない
+ 現状の仕様では返す必要がないので、パスワードは特にどのエンティティも保持しない

### SameUserValidation
+ 同一人物の判定をドメイン層で表現したかった
+ SQLの`where`で名前やステータスを絞るのは非ドメインロジカル
+ 例えば今後退会した人を弾きたければ、このクラスを改修する
  + そしたらクラス名に`Enabled`とか付けても良いのかも

### UserRegistration
+ 十中八九サービスで書かれるロジックをドメインに書いてみる
+ が、リポジトリアクセスは行わせず、アクセス結果ドメインを受けてドメインを返す
+ テストが書ける

### 失敗
+ 仕様上発生する失敗はクラスを用意する
+ ドメイン層に例外は認めない
+ ds層は失敗次第
  + 想定**内**の不正コードを受け取り想定内の不正理由を**手に入れた場合**は仕様上の失敗
  + 想定**外**の不正コードを受け取り想定内の不正理由が**手に入らない場合**は例外
+ フォームおよびバリデーションは関数的に実装する

### 全てのValueObjectがドメインクラスなわけではない
+ 外部システムのエラーコードは別にドメインではない
